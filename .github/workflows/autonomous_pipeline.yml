# 워크플로우 이름
name: AI Commander v2.0 CI/CD Pipeline

# 실행 조건: main 브랜치에 push가 있을 때
on:
  push:
    branches:
      - main

# 워크플로우 전체에서 사용할 환경 변수
env:
  AWS_REGION: ap-southeast-1          # EC2 인스턴스가 있는 리전
  ECR_REPOSITORY: ai-commander-v2     # AWS ECR에 생성할 이미지 저장소 이름

# 실행할 작업들
jobs:
  # ===============================================
  # 작업 1: Docker 이미지 빌드 및 ECR에 업로드
  # ===============================================
  build-and-push:
    name: Build and Push to ECR
    runs-on: ubuntu-latest

    # 권한 설정 (OIDC 사용)
    permissions:
      id-token: write # OIDC 인증을 위해 필수
      contents: read

    steps:
      # 1. GitHub 저장소의 코드를 가져옵니다.
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2. OIDC를 사용하여 GitHub Actions가 AWS에 안전하게 로그인합니다.
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      # 3. AWS ECR(Docker 이미지 저장소)에 로그인합니다.
      - name: Log in to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # 4. Docker 이미지를 빌드하고, 태그를 붙여 ECR에 푸시(업로드)합니다.
      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }} # 커밋 해시를 이미지 태그로 사용하여 버전을 관리
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

  # ===============================================
  # 작업 2: EC2 서버에 최신 버전 배포
  # ===============================================
  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    needs: build-and-push # build-and-push 작업이 성공해야만 이 작업이 시작됩니다.

    steps:
      # 1. EC2 서버에 SSH로 접속하여 배포 스크립트를 실행합니다.
      - name: Deploy to EC2 instance
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_PRIVATE_KEY }}
          script: |
            # 1. 어떤 명령이라도 실패하면 즉시 중단합니다.
            set -e

            # 2. EC2에 부여된 IAM 역할을 사용하여 AWS ECR에 로그인합니다.
            # 이 단계에서는 GitHub Actions의 자격 증명이 필요 없습니다.
            echo "Logging in to Amazon ECR..."
            aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com

            # 3. 이전에 실행 중이던 컨테이너가 있다면 중지하고 삭제합니다.
            echo "Stopping and removing old container..."
            docker stop upbit-bot || true
            docker rm upbit-bot || true

            # 4. ECR에서 최신 버전의 Docker 이미지를 내려받습니다.
            echo "Pulling latest image from ECR..."
            docker pull ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ github.sha }}

            # 5. .env 파일을 동적으로 생성합니다.
            # GitHub Secrets의 값을 EC2 서버에 파일로 안전하게 기록합니다.
            echo "Creating .env file on EC2..."
            echo "UPBIT_ACCESS_KEY=${{ secrets.UPBIT_ACCESS_KEY }}" > .env
            echo "UPBIT_SECRET_KEY=${{ secrets.UPBIT_SECRET_KEY }}" >> .env

            # 6. 최신 이미지를 사용하여 새 컨테이너를 백그라운드에서 실행합니다.
            # --env-file 옵션으로 방금 만든 .env 파일을 컨테이너에 전달합니다.
            echo "Starting new container with .env file..."
            docker run -d \
              --name upbit-bot \
              --restart always \
              --env-file ./.env \
              ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ github.sha }}
            
            # 6. 사용하지 않는 오래된 Docker 이미지를 정리하여 디스크 공간을 확보합니다.
            echo "Cleaning up old images..."
            docker image prune -af
            
            echo "Deployment successful!"